/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.3.1",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://github.com/motdotla/dotenv?sponsor=1",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@definitelytyped/dtslint": "^0.0.133",
        "@types/node": "^18.11.3",
        decache: "^4.6.1",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.5.0",
        tap: "^16.3.0",
        tar: "^6.1.11",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var crypto = require("crypto");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        throw new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          throw new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        throw new Error("INVALID_DOTENV_KEY: Missing key part");
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        throw new Error("INVALID_DOTENV_KEY: Missing environment part");
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      if (options && options.path && options.path.length > 0) {
        dotenvPath = options.path;
      }
      return dotenvPath.endsWith(".vault") ? dotenvPath : `${dotenvPath}.vault`;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options) {
        if (options.path != null) {
          dotenvPath = _resolveHome(options.path);
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        }
      }
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }));
        let processEnv = process.env;
        if (options && options.processEnv != null) {
          processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsed, options);
        return { parsed };
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${dotenvPath} ${e.message}`);
        }
        return { error: e };
      }
    }
    function config(options) {
      const vaultPath = _vaultPath(options);
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      if (!fs.existsSync(vaultPath)) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.slice(0, 12);
      const authTag = ciphertext.slice(-16);
      ciphertext = ciphertext.slice(12, -16);
      try {
        const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const msg = "INVALID_DOTENV_KEY: It must be 64 characters long (or more)";
          throw new Error(msg);
        } else if (decryptionFailed) {
          const msg = "DECRYPTION_FAILED: Please check your DOTENV_KEY";
          throw new Error(msg);
        } else {
          console.error("Error: ", error.code);
          console.error("Error: ", error.message);
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        throw new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CST
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/open-link-wrapper.ts
var import_obsidian2 = require("obsidian");

// src/Console.ts
var import_obsidian = require("obsidian");
var DEBUG = "false";
if (import_obsidian.Platform.isDesktopApp) {
  require_main().config();
  DEBUG = "false";
}
var Console = {
  debug: (...args) => {
    if (DEBUG.trim().toLowerCase() === "true") {
      console.debug(...args);
    }
  },
  log: (...args) => {
    if (DEBUG.trim().toLowerCase() === "true") {
      console.log(...args);
    }
  }
};

// src/open-link-wrapper.ts
function openLinkWrapper(plugin) {
  const openLinkPatched = around(import_obsidian2.Workspace.prototype, {
    openLinkText(old) {
      return async function(...args) {
        if (!plugin.settings.switch) {
          return old.apply(this, args);
        }
        Console.debug("Open Link");
        plugin.link = true;
        setTimeout(async () => {
          plugin.link = false;
        }, 400);
        Console.debug("args: ", args);
        let [linktext, sourcePath, newLeaf, OpenViewState] = args;
        Console.debug("newLeaf", newLeaf);
        const activeLeaf = plugin.getVisibleLeaf();
        Console.debug("getVisibleLeaf", activeLeaf == null ? void 0 : activeLeaf.getDisplayText());
        if (
          // ok // to same page
          linktext.includes(
            sourcePath.split(".").slice(0, -1).join(".")
          ) || linktext.trim().startsWith("#")
        ) {
          Console.debug("to same page");
          return old.apply(this, [
            linktext,
            sourcePath,
            newLeaf = false,
            // don't open new tab
            OpenViewState
          ]);
        } else {
          Console.debug("to other page");
          const activeEl = activeLeaf.parentSplit.containerEl;
          const { leaves, empties } = plugin.getLeaves(activeEl);
          const linkPart = getFirstPartOfWikiLink(linktext);
          const targetFile = app.metadataCache.getFirstLinkpathDest(
            linkPart,
            //→ page.md
            sourcePath
          );
          const duplis = leaves.filter((l) => {
            return plugin.getLeafPath(l) === (targetFile == null ? void 0 : targetFile.path);
          })[0];
          if (activeLeaf && plugin.getPinned(activeLeaf)) {
            Console.debug("getPinned");
            if (duplis) {
              Console.debug("duplis");
              if (linkPart === linktext) {
                Console.debug("no attr");
                setTimeout(() => {
                  app.workspace.setActiveLeaf(duplis, { focus: true });
                }, 0);
              } else {
                Console.debug("attr");
                duplis.detach();
                return old.apply(this, args);
              }
            } else {
              return old.apply(this, args);
            }
          } else {
            Console.debug("no newLeaf");
            if (duplis) {
              Console.debug("duplis");
              if (newLeaf === false) {
                Console.debug("without ctrl");
                if (linkPart === linktext) {
                  Console.debug("no attr");
                  activeLeaf == null ? void 0 : activeLeaf.detach();
                  setTimeout(() => {
                    app.workspace.setActiveLeaf(duplis, { focus: true });
                  }, 0);
                  return;
                } else {
                  Console.debug("attr");
                  duplis.detach();
                  return old.apply(this, args);
                }
              } else {
                Console.debug("with ctrl");
                if (linkPart === linktext) {
                  Console.debug("no attr");
                  setTimeout(() => {
                    app.workspace.setActiveLeaf(duplis, { focus: true });
                  }, 0);
                  return;
                } else {
                  Console.debug("attr");
                  duplis.detach();
                  return old.apply(this, args);
                }
              }
            } else {
              Console.debug("link chg actual page");
              return old.apply(this, args);
            }
          }
        }
      };
    }
  });
  return openLinkPatched;
}
function getFirstPartOfWikiLink(linkText) {
  const separators = "#^|";
  let separatorIndex = linkText.length;
  for (let i = 0; i < separators.length - 1; i++) {
    const index = linkText.indexOf(separators[i]);
    if (index !== -1) {
      separatorIndex = index;
      break;
    }
  }
  const firstPart = linkText.substring(0, separatorIndex);
  return firstPart;
}

// src/open-file-wrapper.ts
var import_obsidian3 = require("obsidian");
function openFileWrapper(plugin) {
  const openFilePatched = around(import_obsidian3.WorkspaceLeaf.prototype, {
    //@ts-ignore
    openFile(old) {
      return async function(...args) {
        var _a;
        if (!plugin.settings.switch || plugin.link) {
          return old.apply(this, args);
        }
        Console.debug("Open File");
        const [file, state] = args;
        Console.debug("state", state);
        const activeLeaf = plugin.getVisibleLeaf();
        const target = file.path;
        if ((activeLeaf == null ? void 0 : activeLeaf.getDisplayText()) === "Files") {
          Console.debug("EXPLORER");
          const activeLeaf2 = plugin.app.workspace.getMostRecentLeaf();
          Console.log("activeLeaf", activeLeaf2 == null ? void 0 : activeLeaf2.getDisplayText());
          const { empties, duplis } = init(activeLeaf2, args, plugin);
          if (!duplis) {
            Console.debug("normal pinned");
            const result = old.apply(this, args);
            return result;
          }
          Console.debug("duplis");
          if (plugin.ctrl || plugin.middleClick) {
            Console.debug("ctrl || middle click");
            await activateDetach(plugin, duplis, empties, 10);
          } else {
            if ((state == null ? void 0 : state.active) === false) {
              Console.debug("drag/insert");
              await activateDetach(plugin, duplis, empties, 10);
              return;
            } else {
              Console.debug("drag on existing tab or popout");
              if (plugin.getLeafPath(activeLeaf2) !== target && !plugin.getPinned(duplis)) {
                Console.log("detach");
                await activateDetach(plugin, duplis, activeLeaf2, 10);
              } else {
                Console.log("normal");
                return old.apply(this, args);
              }
            }
          }
        } else if ((state == null ? void 0 : state.active) === true) {
          const activeLeaf2 = plugin.app.workspace.getLeaf();
          Console.debug("quickswith or drag on tab header");
          const { empties, duplis, activeEl } = init(activeLeaf2, args, plugin);
          if (duplis) {
            Console.debug("duplis");
            if (plugin.ctrl || plugin.middleClick) {
              Console.debug("quick switch ctrl");
              await activateDetach(plugin, duplis, empties, 10);
              await removeEmpty(plugin, activeEl, 0);
            } else {
              Console.debug("quick switch or drag header or today note");
              if (plugin.getLeafPath(activeLeaf2) !== target)
                await activateDetach(plugin, duplis, activeLeaf2, 10);
            }
          } else {
            Console.debug("// today note no existing tab. quick switcher pinned tab");
            const mostRecentLeaf = plugin.app.workspace.getMostRecentLeaf();
            if (plugin.getPinned(mostRecentLeaf)) {
              await removeEmpty(plugin, activeEl, 0);
            }
            old.apply(this, args);
          }
        } else if ((state == null ? void 0 : state.active) === false) {
          const { empties, duplis, activeEl } = init(activeLeaf, args, plugin);
          const isMainWindow = (activeLeaf == null ? void 0 : activeLeaf.view.containerEl.win) === window;
          if (isMainWindow) {
            if (state.hasOwnProperty("state")) {
              Console.log("Hover editor");
              return old.apply(this, args);
            }
            Console.log("isMainWindow");
            Console.log("marqueur");
            (_a = empties == null ? void 0 : empties.pop()) == null ? void 0 : _a.detach();
            await activateLeaf(plugin, duplis, 0);
          } else {
            Console.log("drag on other window");
            if (duplis) {
              if (!plugin.getPinned(duplis)) {
                Console.log("not pinned");
                await activateLeaf(plugin, duplis, 0);
                await removeEmpty(plugin, activeEl, 0);
              } else {
                Console.log("pinned");
                return old.apply(this, args);
              }
            } else {
              return old.apply(this, args);
            }
          }
        } else {
          Console.log("open window normal");
          return old.apply(this, args);
        }
      };
    }
  });
  return openFilePatched;
}
function init(activeLeaf, args, plugin) {
  const [file, state] = args;
  const target = file.path;
  const {
    activeEl,
    leaves,
    empties,
    isTherePin
  } = getConditions(plugin, activeLeaf);
  const duplis = leaves.filter((l) => {
    return plugin.getLeafPath(l) === target;
  })[0];
  Console.debug("duplis.length", leaves.filter((l) => {
    return plugin.getLeafPath(l) === target;
  }).length);
  Console.debug("leaves.length", leaves.length);
  Console.debug("empties.length", empties.length);
  return {
    activeEl,
    leaves,
    empties,
    isTherePin,
    duplis
  };
}
function removeEmpty(plugin, activeEl, timeout) {
  return delayedPromise(timeout, () => {
    var _a;
    const { empties } = plugin.getLeaves(activeEl);
    Console.debug("Detaching leaf");
    (_a = empties == null ? void 0 : empties.pop()) == null ? void 0 : _a.detach();
  });
}
async function activateDetach(plugin, leafToActivate, toDetach, timeout) {
  var _a;
  await activateLeaf(plugin, leafToActivate, timeout);
  if (Array.isArray(toDetach))
    (_a = toDetach.pop()) == null ? void 0 : _a.detach();
  else
    toDetach.detach();
}
function activateLeaf(plugin, leaf, timeout) {
  return delayedPromise(timeout, () => {
    Console.debug("activating leaf");
    plugin.app.workspace.setActiveLeaf(leaf, { focus: true });
  });
}
function delayedPromise(timeout, callback) {
  return new Promise((resolve) => {
    setTimeout(() => {
      const result = callback();
      resolve(result);
    }, timeout);
  });
}
function getConditions(plugin, activeLeaf) {
  const { el: activeEl } = plugin.getLeafProperties(activeLeaf);
  const { leaves, empties, isTherePin } = plugin.getLeaves(activeEl);
  return { activeLeaf, activeEl, leaves, empties, isTherePin };
}

// src/settings.ts
var import_obsidian4 = require("obsidian");
var CSTSettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const content = `Repository: \u{1F334} [1C0D/Obsidian-Close-Similar-Tabs](https://github.com/1C0D/Obsidian-Close-Similar-Tabs) \u{1F334}
		</p>
		`;
    await import_obsidian4.MarkdownRenderer.render(
      app,
      content,
      containerEl,
      "",
      this.plugin
    );
    new import_obsidian4.Setting(containerEl).setName("Quick switch").setDesc("Enable/disable Close Similar Tabs").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.switch).onChange((value) => {
        this.plugin.settings.switch = value;
        this.plugin.saveSettings();
        const message = this.plugin.settings.switch ? "Close similar tabs ON" : "Close similar tabs OFF";
        new import_obsidian4.Notice(`${message}`);
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Close by window").setDesc(
      "Select whether the plugin will only close similar tabs within the same window, or throughout all open windows."
    ).addDropdown((dropdown) => {
      dropdown.addOptions({
        current: "Current window only",
        all: "All windows"
      }).setValue(this.plugin.settings.byWindow).onChange(async (value) => {
        if (value === "all" || value === "current") {
          this.plugin.settings.byWindow = value;
          this.plugin.saveSettings();
        }
      });
    });
    containerEl.createEl("p", {
      text: `options about not having several empty tabs and pinned tabs are getting back soon`
    });
  }
};

// src/constantes.ts
var DEFAULT_SETTINGS = {
  byWindow: "current",
  switch: true
};

// src/main.ts
var CST = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.getLeaves = (activeEl) => {
      const { workspace } = this.app;
      const leaves = [];
      const empties = [];
      let isTherePin = false;
      workspace.iterateAllLeaves((leaf) => {
        const {
          isMainWindow: isMainWindowDupli,
          rootSplit: rootSplitDupli,
          el: dupliEl,
          isSameWindow: isSameWindowDupli
        } = this.getLeafProperties(leaf, true);
        if (isMainWindowDupli && !rootSplitDupli || //not sidebars
        isSameWindowDupli && activeEl != dupliEl || //split window
        !isSameWindowDupli && this.settings.byWindow === "current") {
          return;
        }
        if (this.isEmpty(leaf)) {
          if (this.getPinned(leaf))
            isTherePin = true;
          empties.push(leaf);
          return;
        }
        if (this.getPinned(leaf))
          isTherePin = true;
        leaves.push(leaf);
      });
      return { leaves, empties, isTherePin };
    };
  }
  async onload() {
    await this.loadSettings();
    await this.saveSettings();
    this.addSettingTab(new CSTSettingsTab(this.app, this));
    this.link = false;
    this.registerDomEvent(document, "keydown", (e) => {
      if (e.key === "Control" || e.key === "Meta") {
        Console.debug("ctrl pressed");
        this.ctrl = true;
      }
    });
    this.registerDomEvent(document, "keyup", (e) => {
      if (e.key === "Control" || e.key === "Meta") {
        Console.log("ctrl released");
        this.ctrl = false;
      }
    });
    this.registerDomEvent(document, "mouseup", (e) => {
      if (e.button === 1) {
        Console.debug("middleClick released On");
        this.middleClick = true;
        setTimeout(() => {
          Console.debug("middleClick released off");
          this.middleClick = false;
        }, 200);
      }
    });
    this.register(openLinkWrapper(this));
    this.register(openFileWrapper(this));
    this.addCommand({
      id: "quick-switch",
      name: "Switch",
      callback: async () => {
        this.settings.switch = !this.settings.switch;
        const message = this.settings.switch ? "Close similar tabs ON" : "Close similar tabs OFF";
        new import_obsidian5.Notice(`${message}`);
        await this.saveSettings();
      }
    });
  }
  getVisibleLeaf() {
    var _a;
    return (_a = this.app.workspace.getActiveViewOfType(import_obsidian5.View)) == null ? void 0 : _a.leaf;
  }
  getActiveFileView() {
    var _a;
    return (_a = this.app.workspace.getActiveViewOfType(import_obsidian5.View)) == null ? void 0 : _a.leaf;
  }
  activeLeafInfo() {
    var _a, _b;
    const getVisibleLeafPath = (_a = this.getVisibleLeaf()) == null ? void 0 : _a.getDisplayText();
    const activeFileViewPath = (_b = this.getActiveFileView()) == null ? void 0 : _b.getDisplayText();
    Console.debug("getVisibleLeaf: ", getVisibleLeafPath, " getActiveFileView: ", activeFileViewPath);
  }
  getLeafProperties(leaf, notActive = false) {
    const isMainWindow = (leaf == null ? void 0 : leaf.view.containerEl.win) === window;
    const rootSplit = (leaf == null ? void 0 : leaf.getRoot()) === this.app.workspace.rootSplit;
    const el = leaf == null ? void 0 : leaf.parentSplit.containerEl;
    if (notActive) {
      const isSameWindow = (leaf == null ? void 0 : leaf.view.containerEl.win) == activeWindow;
      return { isMainWindow, rootSplit, el, isSameWindow };
    }
    return { isMainWindow, rootSplit, el };
  }
  getLeafPath(leaf) {
    return leaf == null ? void 0 : leaf.getViewState().state.file;
  }
  getPinned(leaf) {
    return leaf == null ? void 0 : leaf.getViewState().pinned;
  }
  isEmpty(leaf) {
    return (leaf == null ? void 0 : leaf.view.getViewType()) === "empty";
  }
  async loadSettings() {
    this.settings = { ...DEFAULT_SETTINGS, ...await this.loadData() };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
